import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  HttpException,
  HttpStatus,
  ValidationPipe,
  UsePipes,
  Logger
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiParam, ApiQuery } from '@nestjs/swagger';
import { OracleCoordinatorService } from '../services/oracle-coordinator.service';
import { RealSocialDataService } from '../services/real-social-data.service';
import { SocialDataIntegrationService } from '../services/social-data-integration.service';
import { OracleRequestDto } from '../dto/oracle-request.dto';
import { OracleResponseDto } from '../dto/oracle-response.dto';
import { SocialMediaPost } from '../interfaces/social-data-integration.interface';
import { ConfigService } from '@nestjs/config';

@ApiTags('oracle')
@Controller('oracle')
@UsePipes(new ValidationPipe({ transform: true }))
export class OracleController {
  private readonly logger = new Logger(OracleController.name);

  constructor(
    private readonly oracleCoordinator: OracleCoordinatorService,
    private readonly realSocialDataService: RealSocialDataService,
    private readonly socialDataIntegrationService: SocialDataIntegrationService,
    private readonly configService: ConfigService) {}

  @Post('virality')
  @ApiOperation({
    summary: 'Get verifiable virality score from Oracle network',
    description: 'Processes a request through the validator network to achieve consensus and generate a cryptographic proof of the virality score.'
  })
  @ApiResponse({
    status: 200,
    description: 'Virality score with cryptographic proof',
    type: OracleResponseDto
  })
  @ApiResponse({
    status: 400,
    description: 'Invalid request parameters'
  })
  @ApiResponse({
    status: 500,
    description: 'Oracle processing failed'
  })
  async getViralityScore(@Body() request: OracleRequestDto): Promise<OracleResponseDto> {
    this.logger.log(`üì® Received virality request for trend: ${request.trendId}`);

    try {
      const result = await this.oracleCoordinator.processOracleRequest(request);
      this.logger.log(`‚úÖ Virality score generated: ${result.viralityScore.toFixed(4)} for trend: ${request.trendId}`);
      return result;
    } catch (error) {
      this.logger.error(`‚ùå Virality request failed for trend: ${request.trendId}`, error.message);
      throw new HttpException(
        `Oracle processing failed: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  @Get('virality/:trendId')
  @ApiOperation({
    summary: 'Get latest virality score for a trend',
    description: 'Retrieves the most recent virality score and proof for a specific trend from the database.'
  })
  @ApiParam({ name: 'trendId', description: 'The trend identifier' })
  @ApiResponse({
    status: 200,
    description: 'Latest virality score with proof',
    type: OracleResponseDto
  })
  @ApiResponse({
    status: 404,
    description: 'No data found for this trend'
  })
  async getLatestViralityScore(@Param('trendId') trendId: string): Promise<OracleResponseDto> {
    this.logger.log(`üì® Requesting latest virality score for trend: ${trendId}`);

    const result = await this.oracleCoordinator.getLatestOracleData(trendId);

    if (!result) {
      throw new HttpException(
        `No oracle data found for trend: ${trendId}`,
        HttpStatus.NOT_FOUND);
    }

    this.logger.log(`‚úÖ Retrieved latest score: ${result.viralityScore.toFixed(4)} for trend: ${trendId}`);
    return result;
  }

  @Get('proof/:proofHash/verify')
  @ApiOperation({
    summary: 'Verify cryptographic proof',
    description: 'Verifies the validity of a cryptographic proof generated by the Oracle network.'
  })
  @ApiParam({ name: 'proofHash', description: 'The SHA-256 hash of the proof to verify' })
  @ApiResponse({
    status: 200,
    description: 'Proof verification result'
  })
  @ApiResponse({
    status: 404,
    description: 'Proof not found'
  })
  async verifyProof(@Param('proofHash') proofHash: string): Promise<any> {
    this.logger.log(`üîç Verifying proof: ${proofHash.substring(0, 16)}...`);

    const result = await this.oracleCoordinator.verifyProof(proofHash);
    this.logger.log(`‚úÖ Proof verification completed: ${result.verified ? 'VALID' : 'INVALID'}`);

    return result;
  }

  @Get('status')
  @ApiOperation({
    summary: 'Get Oracle network status',
    description: 'Returns the current status of the Oracle network, including validator health and performance metrics.'
  })
  @ApiResponse({
    status: 200,
    description: 'Oracle network status'
  })
  async getOracleStatus(): Promise<any> {
    this.logger.log('üìä Requesting Oracle network status');

    const status = await this.oracleCoordinator.getOracleStatus();

    // Add Phase 2 Oracle specific flags to status
    const enhancedStatus = {
      ...status,
      phase2: {
        enabled: this.configService.get<boolean>('ORACLE_PHASE_2_ENABLED', false),
        realDataIntegration: this.configService.get<boolean>('ORACLE_REAL_DATA_INTEGRATION', true),
        classificationEnabled: this.configService.get<boolean>('ORACLE_CLASSIFICATION_ENABLED', true),
        deceptionDetectionEnabled: this.configService.get<boolean>('ORACLE_DECEPTION_DETECTION_ENABLED', false),
        crossPlatformCorrelation: this.configService.get<boolean>('ORACLE_CROSS_PLATFORM_CORRELATION_ENABLED', true)
      }
    };

    this.logger.log(`‚úÖ Oracle status retrieved - Network: ${status.networkType}, Validators: ${status.validators.healthyValidators}/${status.validators.totalValidators}, Phase 2: ${enhancedStatus.phase2.enabled ? 'ENABLED' : 'DISABLED'}`);

    return enhancedStatus;
  }

  // Phase 2 Oracle endpoints for real social data retrieval
  @Get('social/tiktok')
  @ApiOperation({
    summary: 'Get trending TikTok videos',
    description: 'Fetches trending TikTok videos from real API data with South African filters applied.'
  })
  @ApiQuery({
    name: 'limit',
    required: false,
    type: Number,
    description: 'Maximum number of videos to return (default: 50)'
  })
  @ApiResponse({
    status: 200,
    description: 'Trending TikTok videos',
    type: [SocialMediaPost]
  })
  async getTrendingTikTokVideos(@Query('limit') limit?: number): Promise<SocialMediaPost[]> {
    const videoLimit = limit || 50;
    this.logger.log(`üì± Requesting ${videoLimit} trending TikTok videos`);

    try {
      const videos = await this.realSocialDataService.getTrendingTikTokVideos(videoLimit);
      this.logger.log(`‚úÖ Retrieved ${videos.length} TikTok videos`);
      return videos;
    } catch (error) {
      this.logger.error('‚ùå Failed to fetch TikTok videos:', error.message);
      throw new HttpException(
        `Failed to fetch TikTok videos: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  @Get('social/twitter')
  @ApiOperation({
    summary: 'Get trending Twitter topics',
    description: 'Fetches trending Twitter topics from real API data with South African filters applied.'
  })
  @ApiQuery({
    name: 'limit',
    required: false,
    type: Number,
    description: 'Maximum number of topics to return (default: 100)'
  })
  @ApiResponse({
    status: 200,
    description: 'Trending Twitter topics',
    type: [SocialMediaPost]
  })
  async getTrendingTwitterTopics(@Query('limit') limit?: number): Promise<SocialMediaPost[]> {
    const topicLimit = limit || 100;
    this.logger.log(`üê¶ Requesting ${topicLimit} trending Twitter topics`);

    try {
      const topics = await this.realSocialDataService.getTrendingTwitterTopics(topicLimit);
      this.logger.log(`‚úÖ Retrieved ${topics.length} Twitter topics`);
      return topics;
    } catch (error) {
      this.logger.error('‚ùå Failed to fetch Twitter topics:', error.message);
      throw new HttpException(
        `Failed to fetch Twitter topics: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  @Get('social/instagram')
  @ApiOperation({
    summary: 'Get trending Instagram posts',
    description: 'Fetches trending Instagram posts from real API data with South African filters applied.'
  })
  @ApiQuery({
    name: 'limit',
    required: false,
    type: Number,
    description: 'Maximum number of posts to return (default: 50)'
  })
  @ApiResponse({
    status: 200,
    description: 'Trending Instagram posts',
    type: [SocialMediaPost]
  })
  async getTrendingInstagramPosts(@Query('limit') limit?: number): Promise<SocialMediaPost[]> {
    const postLimit = limit || 50;
    this.logger.log(`üì∑ Requesting ${postLimit} trending Instagram posts`);

    try {
      const posts = await this.realSocialDataService.getTrendingInstagramPosts(postLimit);
      this.logger.log(`‚úÖ Retrieved ${posts.length} Instagram posts`);
      return posts;
    } catch (error) {
      this.logger.error('‚ùå Failed to fetch Instagram posts:', error.message);
      throw new HttpException(
        `Failed to fetch Instagram posts: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  @Get('social/youtube')
  @ApiOperation({
    summary: 'Get trending YouTube videos',
    description: 'Fetches trending YouTube videos from real API data with South African filters applied.'
  })
  @ApiQuery({
    name: 'limit',
    required: false,
    type: Number,
    description: 'Maximum number of videos to return (default: 30)'
  })
  @ApiResponse({
    status: 200,
    description: 'Trending YouTube videos',
    type: [SocialMediaPost]
  })
  async getTrendingYouTubeVideos(@Query('limit') limit?: number): Promise<SocialMediaPost[]> {
    const videoLimit = limit || 30;
    this.logger.log(`üì∫ Requesting ${videoLimit} trending YouTube videos`);

    try {
      const videos = await this.realSocialDataService.getTrendingYouTubeVideos(videoLimit);
      this.logger.log(`‚úÖ Retrieved ${videos.length} YouTube videos`);
      return videos;
    } catch (error) {
      this.logger.error('‚ùå Failed to fetch YouTube videos:', error.message);
      throw new HttpException(
        `Failed to fetch YouTube videos: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  @Get('social/facebook')
  @ApiOperation({
    summary: 'Get trending Facebook posts',
    description: 'Fetches trending Facebook posts from real API data with South African filters applied.'
  })
  @ApiQuery({
    name: 'limit',
    required: false,
    type: Number,
    description: 'Maximum number of posts to return (default: 50)'
  })
  @ApiResponse({
    status: 200,
    description: 'Trending Facebook posts',
    type: [SocialMediaPost]
  })
  async getTrendingFacebookPosts(@Query('limit') limit?: number): Promise<SocialMediaPost[]> {
    const postLimit = limit || 50;
    this.logger.log(`üìò Requesting ${postLimit} trending Facebook posts`);

    try {
      const posts = await this.realSocialDataService.getTrendingFacebookPosts(postLimit);
      this.logger.log(`‚úÖ Retrieved ${posts.length} Facebook posts`);
      return posts;
    } catch (error) {
      this.logger.error('‚ùå Failed to fetch Facebook posts:', error.message);
      throw new HttpException(
        `Failed to fetch Facebook posts: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  @Get('social/sa-trends')
  @ApiOperation({
    summary: 'Get aggregated South African trends',
    description: 'Fetches aggregated South African trends from all platforms with comprehensive filtering.'
  })
  @ApiResponse({
    status: 200,
    description: 'Aggregated South African trends',
    type: [SocialMediaPost]
  })
  async getSouthAfricanTrends(): Promise<SocialMediaPost[]> {
    this.logger.log('üáøüá¶ Requesting aggregated South African trends');

    try {
      const trends = await this.realSocialDataService.getSouthAfricanTrends();
      this.logger.log(`‚úÖ Retrieved ${trends.length} South African trends`);
      return trends;
    } catch (error) {
      this.logger.error('‚ùå Failed to fetch South African trends:', error.message);
      throw new HttpException(
        `Failed to fetch South African trends: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  // Classification endpoints
  @Post('classify')
  @ApiOperation({
    summary: 'Classify trend from social media posts',
    description: 'Analyzes social media posts to classify trend, detect deception, and assess credibility.'
  })
  @ApiResponse({
    status: 200,
    description: 'Trend classification result'
  })
  async classifyTrend(@Body() posts: SocialMediaPost[]): Promise<any> {
    this.logger.log(`üîç Classifying trend from ${posts.length} social media posts`);

    try {
      const classification = await this.socialDataIntegrationService.classifyTrend(posts);
      this.logger.log(`‚úÖ Trend classified as: ${classification.category} with confidence: ${classification.confidence}`);
      return classification;
    } catch (error) {
      this.logger.error('‚ùå Failed to classify trend:', error.message);
      throw new HttpException(
        `Failed to classify trend: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  @Get('classify/:trendId')
  @ApiOperation({
    summary: 'Get classification result by trend ID',
    description: 'Retrieves existing classification result for a specific trend ID.'
  })
  @ApiParam({ name: 'trendId', description: 'The trend identifier' })
  @ApiResponse({
    status: 200,
    description: 'Classification result'
  })
  @ApiResponse({
    status: 404,
    description: 'Classification not found'
  })
  async getClassificationByTrendId(@Param('trendId') trendId: string): Promise<any> {
    this.logger.log(`üîç Requesting classification for trend: ${trendId}`);

    try {
      const classification = await this.socialDataIntegrationService.getClassificationByTrendId(trendId);

      if (!classification) {
        throw new HttpException(
          `Classification not found for trend: ${trendId}`,
          HttpStatus.NOT_FOUND);
      }

      this.logger.log(`‚úÖ Retrieved classification for trend: ${trendId}`);
      return classification;
    } catch (error) {
      if (error instanceof HttpException) {
        throw error;
      }
      this.logger.error(`‚ùå Failed to get classification for trend: ${trendId}`, error.message);
      throw new HttpException(
        `Failed to get classification: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  @Post('detect-deception')
  @ApiOperation({
    summary: 'Detect deception in social media posts',
    description: 'Analyzes social media posts to detect potential deception, fake news, or misinformation.'
  })
  @ApiResponse({
    status: 200,
    description: 'Deception detection result'
  })
  async detectDeception(@Body() posts: SocialMediaPost[]): Promise<any> {
    this.logger.log(`üîç Analyzing ${posts.length} posts for deception`);

    try {
      const deceptionResult = await this.socialDataIntegrationService.detectDeception(posts, []);
      this.logger.log(`‚úÖ Deception analysis completed: ${deceptionResult.isDeceptive ? 'DECEPTIVE' : 'AUTHENTIC'} (confidence: ${deceptionResult.confidence})`);
      return deceptionResult;
    } catch (error) {
      this.logger.error('‚ùå Failed to detect deception:', error.message);
      throw new HttpException(
        `Failed to detect deception: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  @Get('history/:trendId')
  @ApiOperation({
    summary: 'Get historical Oracle data for a trend',
    description: 'Retrieves historical virality scores and proofs for a specific trend.'
  })
  @ApiParam({ name: 'trendId', description: 'The trend identifier' })
  @ApiQuery({
    name: 'limit',
    required: false,
    type: Number,
    description: 'Maximum number of records to return (default: 10)'
  })
  @ApiResponse({
    status: 200,
    description: 'Historical Oracle data'
  })
  async getOracleHistory(
    @Param('trendId') trendId: string,
    @Query('limit') limit?: number): Promise<any[]> {
    this.logger.log(`üìà Requesting Oracle history for trend: ${trendId}, limit: ${limit || 10}`);

    const history = await this.oracleCoordinator.getOracleHistory(trendId, limit);
    this.logger.log(`‚úÖ Retrieved ${history.length} historical records for trend: ${trendId}`);

    return history;
  }

  @Get('health')
  @ApiOperation({
    summary: 'Health check endpoint',
    description: 'Simple health check to verify Oracle service is running.'
  })
  @ApiResponse({
    status: 200,
    description: 'Service is healthy'
  })
  async healthCheck(): Promise<any> {
    return {
      status: 'healthy',
      service: 'oracle-coordinator',
      timestamp: new Date().toISOString(),
      uptime: process.uptime()
    };
  }

  @Get('metrics')
  @ApiOperation({
    summary: 'Get Oracle performance metrics',
    description: 'Returns detailed performance metrics for the Oracle network.'
  })
  @ApiResponse({
    status: 200,
    description: 'Performance metrics'
  })
  async getMetrics(): Promise<any> {
    this.logger.log('üìä Requesting Oracle metrics');

    const status = await this.oracleCoordinator.getOracleStatus();

    return {
      network: {
        type: status.networkType,
        uptime: status.uptime,
        lastUpdate: status.lastUpdate
      },
      performance: {
        totalProofs: status.totalProofs,
        recentProofs24h: status.recentProofs24h,
        averageConsensusStrength: status.averageConsensusStrength
      },
      validators: {
        total: status.validators.totalValidators,
        healthy: status.validators.healthyValidators,
        consensusRequired: status.validators.consensusRequired,
        maxVariance: status.validators.maxVariance,
        details: status.validators.validators
      },
      features: status.features
    };
  }
}
